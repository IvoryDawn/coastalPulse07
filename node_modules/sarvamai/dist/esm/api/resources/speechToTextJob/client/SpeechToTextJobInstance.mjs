/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as fs from "fs";
import * as path from "path";
import fetch from "node-fetch";
export class SpeechToTextJobInstance {
    constructor(jobId, client) {
        this._jobId = jobId;
        this._client = client;
    }
    /**
     * Returns the job ID associated with this job instance.
     */
    get jobId() {
        return this._jobId;
    }
    /**
     * Upload input audio files for the speech-to-text job.
     *
     * @param filePaths - Array of full paths to local audio files
     * @param timeoutInSeconds - The maximum time to wait for the upload to complete (default: 60)
     * @returns Promise<boolean> - True if all files are uploaded successfully
     */
    uploadFiles(filePaths_1) {
        return __awaiter(this, arguments, void 0, function* (filePaths, timeoutInSeconds = 60) {
            const fileNames = filePaths.map(p => path.basename(p));
            const uploadLinksResponse = yield this._client.getUploadLinks({
                job_id: this._jobId,
                files: fileNames
            });
            for (const filePath of filePaths) {
                const fileName = path.basename(filePath);
                const url = uploadLinksResponse.upload_urls[fileName].file_url;
                const fileBuffer = fs.readFileSync(filePath);
                const mimeType = this.getMimeType(filePath);
                const response = yield fetch(url, {
                    method: 'PUT',
                    body: fileBuffer,
                    headers: {
                        'x-ms-blob-type': 'BlockBlob',
                        'Content-Type': mimeType
                    },
                });
                if (response.status < 200 || response.status > 226) {
                    throw new Error(`Upload failed for ${fileName}: ${response.status}`);
                }
            }
            return true;
        });
    }
    /**
     * Polls job status until it completes or fails.
     *
     * @param pollIntervalSeconds - Time in seconds between polling attempts (default: 5)
     * @param timeoutSeconds - Maximum time to wait for completion in seconds (default: 600)
     * @returns Promise<SarvamAI.JobStatusV1Response> - Final job status
     * @throws Error if the job does not complete within the given timeout
     */
    waitUntilComplete() {
        return __awaiter(this, arguments, void 0, function* (pollIntervalSeconds = 5, timeoutSeconds = 600) {
            const startTime = Date.now();
            while (true) {
                const status = yield this.getStatus();
                const state = status.job_state.toLowerCase();
                if (state === 'completed' || state === 'failed') {
                    return status;
                }
                if (Date.now() - startTime > timeoutSeconds * 1000) {
                    throw new Error(`Job ${this._jobId} did not complete within ${timeoutSeconds} seconds.`);
                }
                yield new Promise(resolve => setTimeout(resolve, pollIntervalSeconds * 1000));
            }
        });
    }
    /**
     * Get the mapping of input files to their corresponding output files.
     *
     * @returns Promise<Array<{input_file: string, output_file: string}>> - List of mappings
     */
    getOutputMappings() {
        return __awaiter(this, void 0, void 0, function* () {
            const jobStatus = yield this.getStatus();
            return (jobStatus.job_details || [])
                .filter(detail => detail.inputs && detail.outputs && detail.inputs.length > 0 && detail.outputs.length > 0)
                .map(detail => ({
                input_file: detail.inputs[0].file_name,
                output_file: detail.outputs[0].file_name
            }));
        });
    }
    /**
     * Download output files to the specified directory.
     *
     * @param outputDir - Local directory where outputs will be saved
     * @returns Promise<boolean> - True if all files downloaded successfully
     * @throws Error if a file fails to download
     */
    downloadOutputs(outputDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const mappings = yield this.getOutputMappings();
            const fileNames = mappings.map(m => m.output_file);
            const downloadLinksResponse = yield this._client.getDownloadLinks({
                job_id: this._jobId,
                files: fileNames
            });
            // Create output directory if it doesn't exist
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
            }
            for (const mapping of mappings) {
                const url = downloadLinksResponse.download_urls[mapping.output_file].file_url;
                const response = yield fetch(url);
                if (response.status < 200 || response.status > 226) {
                    throw new Error(`Download failed for ${mapping.output_file}: ${response.status}`);
                }
                const outputPath = path.join(outputDir, `${mapping.input_file}.json`);
                const buffer = yield response.arrayBuffer();
                fs.writeFileSync(outputPath, Buffer.from(buffer));
            }
            return true;
        });
    }
    /**
     * Retrieve the current status of the job.
     */
    getStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._client.getStatus(this._jobId);
            return response;
        });
    }
    /**
     * Start the speech-to-text job processing.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._client.start(this._jobId);
            return response;
        });
    }
    /**
     * Check if the job exists in the system.
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.getStatus();
                return true;
            }
            catch (error) {
                if (error.statusCode && (error.statusCode === 404 || error.statusCode === 400)) {
                    return false;
                }
                throw error;
            }
        });
    }
    /**
     * Check if the job is either completed or failed.
     */
    isComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.getStatus();
            const state = status.job_state.toLowerCase();
            return state === 'completed' || state === 'failed';
        });
    }
    /**
     * Check if the job completed successfully.
     */
    isSuccessful() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.getStatus();
            return status.job_state.toLowerCase() === 'completed';
        });
    }
    /**
     * Check if the job has failed.
     */
    isFailed() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.getStatus();
            return status.job_state.toLowerCase() === 'failed';
        });
    }
    getMimeType(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const mimeTypes = {
            '.wav': 'audio/wav',
            '.mp3': 'audio/mpeg',
            '.m4a': 'audio/mp4',
            '.aac': 'audio/aac',
            '.ogg': 'audio/ogg',
            '.flac': 'audio/flac'
        };
        return mimeTypes[ext] || 'audio/wav';
    }
}
